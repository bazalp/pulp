// Code generated by Prisma Client Rust. DO NOT EDIT

#![allow(warnings, unused)]
pub static DATAMODEL_STR: &'static str =
  include_str!("/Users/vincentsourice/Sites/perso2022/pulp/src-tauri/prisma/schema.prisma");
static DATABASE_STR: &'static str = "sqlite";
use ::prisma_client_rust::migrations::include_dir;
pub static MIGRATIONS_DIR: &::prisma_client_rust::migrations::include_dir::Dir = &::prisma_client_rust::migrations::include_dir::include_dir!(
  "/Users/vincentsourice/Sites/perso2022/pulp/src-tauri/prisma/migrations"
);
pub async fn new_client() -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
  PrismaClient::_builder().build().await
}
pub async fn new_client_with_url(
  url: &str,
) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
  PrismaClient::_builder()
    .with_url(url.to_string())
    .build()
    .await
}
pub mod directory {
  use super::_prisma::*;
  use super::*;
  pub mod path {
    use super::super::*;
    use super::_prisma::*;
    use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
    pub struct Set(pub String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetPath(value.0)
      }
    }
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
      OrderByParam::Path(direction)
    }
    pub fn equals<T: From<UniqueWhereParam>>(value: String) -> T {
      UniqueWhereParam::PathEquals(value).into()
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::Path(_prisma::read_filters::StringFilter::InVec(value))
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::Path(_prisma::read_filters::StringFilter::NotInVec(value))
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::Path(_prisma::read_filters::StringFilter::Lt(value))
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::Path(_prisma::read_filters::StringFilter::Lte(value))
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::Path(_prisma::read_filters::StringFilter::Gt(value))
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::Path(_prisma::read_filters::StringFilter::Gte(value))
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::Path(_prisma::read_filters::StringFilter::Contains(value))
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::Path(_prisma::read_filters::StringFilter::StartsWith(value))
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::Path(_prisma::read_filters::StringFilter::EndsWith(value))
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::Path(_prisma::read_filters::StringFilter::Not(value))
    }
    pub struct Include;
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::Path(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel("path")
      }
    }
    pub struct Select;
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::Path(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel("path")
      }
    }
  }
  pub mod name {
    use super::super::*;
    use super::_prisma::*;
    use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
    pub struct Set(pub String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetName(value.0)
      }
    }
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
      OrderByParam::Name(direction)
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::Name(_prisma::read_filters::StringFilter::Equals(value))
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::Name(_prisma::read_filters::StringFilter::InVec(value))
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::Name(_prisma::read_filters::StringFilter::NotInVec(value))
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::Name(_prisma::read_filters::StringFilter::Lt(value))
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::Name(_prisma::read_filters::StringFilter::Lte(value))
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::Name(_prisma::read_filters::StringFilter::Gt(value))
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::Name(_prisma::read_filters::StringFilter::Gte(value))
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::Name(_prisma::read_filters::StringFilter::Contains(value))
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::Name(_prisma::read_filters::StringFilter::StartsWith(value))
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::Name(_prisma::read_filters::StringFilter::EndsWith(value))
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::Name(_prisma::read_filters::StringFilter::Not(value))
    }
    pub struct Include;
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::Name(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel("name")
      }
    }
    pub struct Select;
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::Name(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel("name")
      }
    }
  }
  pub mod files {
    use super::super::*;
    use super::_prisma::*;
    use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
    pub struct Fetch(pub file::ManyArgs);
    impl Fetch {
      pub fn with(mut self, params: impl Into<file::WithParam>) -> Self {
        self.0 = self.0.with(params.into());
        self
      }
      pub fn order_by(mut self, param: file::OrderByParam) -> Self {
        self.0 = self.0.order_by(param);
        self
      }
      pub fn skip(mut self, value: i64) -> Self {
        self.0 = self.0.skip(value);
        self
      }
      pub fn take(mut self, value: i64) -> Self {
        self.0 = self.0.take(value);
        self
      }
      pub fn cursor(mut self, value: file::UniqueWhereParam) -> Self {
        self.0 = self.0.cursor(value.into());
        self
      }
    }
    impl From<Fetch> for WithParam {
      fn from(fetch: Fetch) -> Self {
        WithParam::Files(fetch.0)
      }
    }
    pub fn fetch(params: Vec<file::WhereParam>) -> Fetch {
      Fetch(file::ManyArgs::new(params))
    }
    pub struct Connect(pub Vec<file::UniqueWhereParam>);
    impl From<Connect> for SetParam {
      fn from(value: Connect) -> Self {
        Self::ConnectFiles(value.0)
      }
    }
    pub fn connect<T: From<Connect>>(params: Vec<file::UniqueWhereParam>) -> T {
      Connect(params).into()
    }
    pub fn disconnect(params: Vec<file::UniqueWhereParam>) -> SetParam {
      SetParam::DisconnectFiles(params)
    }
    pub fn set(params: Vec<file::UniqueWhereParam>) -> SetParam {
      SetParam::SetFiles(params)
    }
    pub fn some(value: Vec<file::WhereParam>) -> WhereParam {
      WhereParam::FilesSome(value)
    }
    pub fn every(value: Vec<file::WhereParam>) -> WhereParam {
      WhereParam::FilesEvery(value)
    }
    pub fn none(value: Vec<file::WhereParam>) -> WhereParam {
      WhereParam::FilesNone(value)
    }
    pub enum Include {
      Select(file::ManyArgs, Vec<file::SelectParam>),
      Include(file::ManyArgs, Vec<file::IncludeParam>),
      Fetch(file::ManyArgs),
    }
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::Files(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        let (args, selections) = match self {
          Self::Select(args, selections) => (
            args.to_graphql().0,
            selections.into_iter().map(|s| s.to_selection()).collect(),
          ),
          Self::Include(args, selections) => (args.to_graphql().0, {
            let mut nested_selections =
              <file::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
            nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
            nested_selections
          }),
          Self::Fetch(args) => (
            args.to_graphql().0,
            <file::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
          ),
        };
        ::prisma_client_rust::Selection::new("files", None, args, selections)
      }
      pub fn select(args: file::ManyArgs, nested_selections: Vec<file::SelectParam>) -> Self {
        Self::Select(args, nested_selections)
      }
      pub fn include(args: file::ManyArgs, nested_selections: Vec<file::IncludeParam>) -> Self {
        Self::Include(args, nested_selections)
      }
    }
    pub enum Select {
      Select(file::ManyArgs, Vec<file::SelectParam>),
      Include(file::ManyArgs, Vec<file::IncludeParam>),
      Fetch(file::ManyArgs),
    }
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::Files(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        let (args, selections) = match self {
          Self::Select(args, selections) => (
            args.to_graphql().0,
            selections.into_iter().map(|s| s.to_selection()).collect(),
          ),
          Self::Include(args, selections) => (args.to_graphql().0, {
            let mut nested_selections = vec![];
            nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
            nested_selections
          }),
          Self::Fetch(args) => (
            args.to_graphql().0,
            <file::Types as ::prisma_client_rust::ModelTypes>::scalar_selections(),
          ),
        };
        ::prisma_client_rust::Selection::new("files", None, args, selections)
      }
      pub fn select(args: file::ManyArgs, nested_selections: Vec<file::SelectParam>) -> Self {
        Self::Select(args, nested_selections)
      }
      pub fn include(args: file::ManyArgs, nested_selections: Vec<file::IncludeParam>) -> Self {
        Self::Include(args, nested_selections)
      }
    }
  }
  pub mod visibility {
    use super::super::*;
    use super::_prisma::*;
    use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
    pub struct Set(pub bool);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetVisibility(value.0)
      }
    }
    pub fn set<T: From<Set>>(value: bool) -> T {
      Set(value).into()
    }
    pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
      OrderByParam::Visibility(direction)
    }
    pub fn equals(value: bool) -> WhereParam {
      WhereParam::Visibility(_prisma::read_filters::BoolFilter::Equals(value))
    }
    pub fn not(value: bool) -> WhereParam {
      WhereParam::Visibility(_prisma::read_filters::BoolFilter::Not(value))
    }
    pub struct Include;
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::Visibility(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel("visibility")
      }
    }
    pub struct Select;
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::Visibility(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel("visibility")
      }
    }
  }
  pub mod created_at {
    use super::super::*;
    use super::_prisma::*;
    use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
    pub struct Set(
      pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
    );
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetCreatedAt(value.0)
      }
    }
    pub fn set<T: From<Set>>(
      value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
    ) -> T {
      Set(value).into()
    }
    pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
      OrderByParam::CreatedAt(direction)
    }
    pub fn equals(
      value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
    ) -> WhereParam {
      WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Equals(value))
    }
    pub fn in_vec(
      value: Vec<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>,
    ) -> WhereParam {
      WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::InVec(value))
    }
    pub fn not_in_vec(
      value: Vec<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>,
    ) -> WhereParam {
      WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::NotInVec(value))
    }
    pub fn lt(
      value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
    ) -> WhereParam {
      WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Lt(value))
    }
    pub fn lte(
      value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
    ) -> WhereParam {
      WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Lte(value))
    }
    pub fn gt(
      value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
    ) -> WhereParam {
      WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Gt(value))
    }
    pub fn gte(
      value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
    ) -> WhereParam {
      WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Gte(value))
    }
    pub fn not(
      value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
    ) -> WhereParam {
      WhereParam::CreatedAt(_prisma::read_filters::DateTimeFilter::Not(value))
    }
    pub struct Include;
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::CreatedAt(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel("createdAt")
      }
    }
    pub struct Select;
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::CreatedAt(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel("createdAt")
      }
    }
  }
  pub mod updated_at {
    use super::super::*;
    use super::_prisma::*;
    use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
    pub struct Set(
      pub ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
    );
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetUpdatedAt(value.0)
      }
    }
    pub fn set<T: From<Set>>(
      value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
    ) -> T {
      Set(value).into()
    }
    pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
      OrderByParam::UpdatedAt(direction)
    }
    pub fn equals(
      value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
    ) -> WhereParam {
      WhereParam::UpdatedAt(_prisma::read_filters::DateTimeFilter::Equals(value))
    }
    pub fn in_vec(
      value: Vec<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>,
    ) -> WhereParam {
      WhereParam::UpdatedAt(_prisma::read_filters::DateTimeFilter::InVec(value))
    }
    pub fn not_in_vec(
      value: Vec<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>,
    ) -> WhereParam {
      WhereParam::UpdatedAt(_prisma::read_filters::DateTimeFilter::NotInVec(value))
    }
    pub fn lt(
      value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
    ) -> WhereParam {
      WhereParam::UpdatedAt(_prisma::read_filters::DateTimeFilter::Lt(value))
    }
    pub fn lte(
      value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
    ) -> WhereParam {
      WhereParam::UpdatedAt(_prisma::read_filters::DateTimeFilter::Lte(value))
    }
    pub fn gt(
      value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
    ) -> WhereParam {
      WhereParam::UpdatedAt(_prisma::read_filters::DateTimeFilter::Gt(value))
    }
    pub fn gte(
      value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
    ) -> WhereParam {
      WhereParam::UpdatedAt(_prisma::read_filters::DateTimeFilter::Gte(value))
    }
    pub fn not(
      value: ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
    ) -> WhereParam {
      WhereParam::UpdatedAt(_prisma::read_filters::DateTimeFilter::Not(value))
    }
    pub struct Include;
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::UpdatedAt(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel("updatedAt")
      }
    }
    pub struct Select;
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::UpdatedAt(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel("updatedAt")
      }
    }
  }
  pub fn create(
    path: String,
    name: String,
    visibility: bool,
    _params: Vec<SetParam>,
  ) -> (String, String, bool, Vec<SetParam>) {
    (path, name, visibility, _params)
  }
  pub fn create_unchecked(
    path: String,
    name: String,
    visibility: bool,
    _params: Vec<SetParam>,
  ) -> (String, String, bool, Vec<SetParam>) {
    (path, name, visibility, _params)
  }
  #[macro_export]
  macro_rules ! _select_directory { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: directory :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = $ crate :: prisma :: directory :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([$ crate :: prisma :: directory :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: directory :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = $ crate :: prisma :: directory :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([$ crate :: prisma :: directory :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { path , name , files , visibility , created_at , updated_at } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: directory :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: directory :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: directory :: select ! (@ field_serde_name ; $ field) , ", ") , + ,)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: directory :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: directory :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: directory :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["path" , "name" , "files" , "visibility" , "createdAt" , "updatedAt"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: directory :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; path) => { String } ; (@ field_type ; name) => { String } ; (@ field_type ; files : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < files :: Data > } ; (@ field_type ; files) => { Vec < crate :: prisma :: file :: Data > } ; (@ field_type ; visibility) => { bool } ; (@ field_type ; created_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; updated_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Directory" , available relations are "path, name, files, visibility, created_at, updated_at")) } ; (@ field_module ; files : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: file :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; path) => { Into :: < $ crate :: prisma :: directory :: SelectParam > :: into ($ crate :: prisma :: directory :: path :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < $ crate :: prisma :: directory :: SelectParam > :: into ($ crate :: prisma :: directory :: name :: Select) } ; (@ selection_field_to_selection_param ; files $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: directory :: SelectParam > :: into ($ crate :: prisma :: directory :: files :: Select :: $ selection_mode ($ crate :: prisma :: file :: ManyArgs :: new ($ crate :: prisma :: file :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: file :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; files $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: directory :: SelectParam > :: into ($ crate :: prisma :: directory :: files :: Select :: Fetch ($ crate :: prisma :: file :: ManyArgs :: new ($ crate :: prisma :: file :: select ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; visibility) => { Into :: < $ crate :: prisma :: directory :: SelectParam > :: into ($ crate :: prisma :: directory :: visibility :: Select) } ; (@ selection_field_to_selection_param ; created_at) => { Into :: < $ crate :: prisma :: directory :: SelectParam > :: into ($ crate :: prisma :: directory :: created_at :: Select) } ; (@ selection_field_to_selection_param ; updated_at) => { Into :: < $ crate :: prisma :: directory :: SelectParam > :: into ($ crate :: prisma :: directory :: updated_at :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: directory :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; path) => { "path" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; files) => { "files" } ; (@ field_serde_name ; visibility) => { "visibility" } ; (@ field_serde_name ; created_at) => { "createdAt" } ; (@ field_serde_name ; updated_at) => { "updatedAt" } ; }
  pub use _select_directory as select;
  pub enum SelectParam {
    Path(path::Select),
    Name(name::Select),
    Files(files::Select),
    Visibility(visibility::Select),
    CreatedAt(created_at::Select),
    UpdatedAt(updated_at::Select),
  }
  impl SelectParam {
    pub fn to_selection(self) -> ::prisma_client_rust::Selection {
      match self {
        Self::Path(data) => data.to_selection(),
        Self::Name(data) => data.to_selection(),
        Self::Files(data) => data.to_selection(),
        Self::Visibility(data) => data.to_selection(),
        Self::CreatedAt(data) => data.to_selection(),
        Self::UpdatedAt(data) => data.to_selection(),
      }
    }
  }
  #[macro_export]
  macro_rules ! _include_directory { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: directory :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = $ crate :: prisma :: directory :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([$ crate :: prisma :: directory :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < $ crate :: prisma :: directory :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: directory :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = $ crate :: prisma :: directory :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([$ crate :: prisma :: directory :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < $ crate :: prisma :: directory :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { files } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub path : String , pub name : String , pub visibility : bool , pub created_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , pub updated_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , $ (pub $ field : $ crate :: prisma :: directory :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (path) , stringify ! (name) , stringify ! (visibility) , stringify ! (created_at) , stringify ! (updated_at)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: directory :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: directory :: include ! (@ field_serde_name ; path) , & self . path) ? ; state . serialize_field ($ crate :: prisma :: directory :: include ! (@ field_serde_name ; name) , & self . name) ? ; state . serialize_field ($ crate :: prisma :: directory :: include ! (@ field_serde_name ; visibility) , & self . visibility) ? ; state . serialize_field ($ crate :: prisma :: directory :: include ! (@ field_serde_name ; created_at) , & self . created_at) ? ; state . serialize_field ($ crate :: prisma :: directory :: include ! (@ field_serde_name ; updated_at) , & self . updated_at) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , path , name , visibility , created_at , updated_at } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: directory :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: directory :: include ! (@ field_serde_name ; path) , ", " , $ crate :: prisma :: directory :: include ! (@ field_serde_name ; name) , ", " , $ crate :: prisma :: directory :: include ! (@ field_serde_name ; visibility) , ", " , $ crate :: prisma :: directory :: include ! (@ field_serde_name ; created_at) , ", " , $ crate :: prisma :: directory :: include ! (@ field_serde_name ; updated_at) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: directory :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: directory :: include ! (@ field_serde_name ; path) => Ok (Field :: path) , $ crate :: prisma :: directory :: include ! (@ field_serde_name ; name) => Ok (Field :: name) , $ crate :: prisma :: directory :: include ! (@ field_serde_name ; visibility) => Ok (Field :: visibility) , $ crate :: prisma :: directory :: include ! (@ field_serde_name ; created_at) => Ok (Field :: created_at) , $ crate :: prisma :: directory :: include ! (@ field_serde_name ; updated_at) => Ok (Field :: updated_at) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut path = None ; let mut name = None ; let mut visibility = None ; let mut created_at = None ; let mut updated_at = None ; while let Some (key) = map . next_key () ? { match key { Field :: path => { if path . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: directory :: include ! (@ field_serde_name ; path))) ; } path = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: directory :: include ! (@ field_serde_name ; name))) ; } name = Some (map . next_value () ?) ; } Field :: visibility => { if visibility . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: directory :: include ! (@ field_serde_name ; visibility))) ; } visibility = Some (map . next_value () ?) ; } Field :: created_at => { if created_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: directory :: include ! (@ field_serde_name ; created_at))) ; } created_at = Some (map . next_value () ?) ; } Field :: updated_at => { if updated_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: directory :: include ! (@ field_serde_name ; updated_at))) ; } updated_at = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: directory :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: directory :: include ! (@ field_serde_name ; $ field))) ? ;) * let path = path . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: directory :: include ! (@ field_serde_name ; path))) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: directory :: include ! (@ field_serde_name ; name))) ? ; let visibility = visibility . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: directory :: include ! (@ field_serde_name ; visibility))) ? ; let created_at = created_at . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: directory :: include ! (@ field_serde_name ; created_at))) ? ; let updated_at = updated_at . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: directory :: include ! (@ field_serde_name ; updated_at))) ? ; Ok (Data { path , name , visibility , created_at , updated_at , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["path" , "name" , "files" , "visibility" , "createdAt" , "updatedAt"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: directory :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; files : $ selection_mode : ident { $ ($ selections : tt) + }) => { Vec < files :: Data > } ; (@ field_type ; files) => { Vec < crate :: prisma :: file :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Directory" , available relations are "files")) } ; (@ field_module ; files : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: file :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; files $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: directory :: IncludeParam > :: into ($ crate :: prisma :: directory :: files :: Include :: $ selection_mode ($ crate :: prisma :: file :: ManyArgs :: new ($ crate :: prisma :: file :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ? , $ crate :: prisma :: file :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; files $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: directory :: IncludeParam > :: into ($ crate :: prisma :: directory :: files :: Include :: Fetch ($ crate :: prisma :: file :: ManyArgs :: new ($ crate :: prisma :: file :: include ! (@ filters_to_args ; $ ($ ($ filters) +) ?)) $ ($ (. $ arg ($ ($ arg_params) *)) *) ?) ,) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: directory :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; path) => { "path" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; files) => { "files" } ; (@ field_serde_name ; visibility) => { "visibility" } ; (@ field_serde_name ; created_at) => { "createdAt" } ; (@ field_serde_name ; updated_at) => { "updatedAt" } ; }
  pub use _include_directory as include;
  pub enum IncludeParam {
    Path(path::Include),
    Name(name::Include),
    Files(files::Include),
    Visibility(visibility::Include),
    CreatedAt(created_at::Include),
    UpdatedAt(updated_at::Include),
  }
  impl IncludeParam {
    pub fn to_selection(self) -> ::prisma_client_rust::Selection {
      match self {
        Self::Path(data) => data.to_selection(),
        Self::Name(data) => data.to_selection(),
        Self::Files(data) => data.to_selection(),
        Self::Visibility(data) => data.to_selection(),
        Self::CreatedAt(data) => data.to_selection(),
        Self::UpdatedAt(data) => data.to_selection(),
      }
    }
  }
  #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
  pub struct Data {
    #[serde(rename = "path")]
    pub path: String,
    #[serde(rename = "name")]
    pub name: String,
    #[serde(rename = "files")]
    pub files: Option<Vec<super::file::Data>>,
    #[serde(rename = "visibility")]
    pub visibility: bool,
    #[serde(rename = "createdAt")]
    pub created_at:
      ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
    #[serde(rename = "updatedAt")]
    pub updated_at:
      ::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>,
  }
  impl Data {
    pub fn files(
      &self,
    ) -> Result<&Vec<super::file::Data>, ::prisma_client_rust::RelationNotFetchedError> {
      self
        .files
        .as_ref()
        .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
          stringify!(files),
        ))
    }
  }
  #[derive(Clone)]
  pub enum WithParam {
    Files(super::file::ManyArgs),
  }
  impl Into<::prisma_client_rust::Selection> for WithParam {
    fn into(self) -> ::prisma_client_rust::Selection {
      match self {
        Self::Files(args) => {
          let (arguments, mut nested_selections) = args.to_graphql();
          nested_selections
            .extend(<super::file::Types as ::prisma_client_rust::ModelTypes>::scalar_selections());
          ::prisma_client_rust::Selection::new("files", None, arguments, nested_selections)
        }
      }
    }
  }
  #[derive(Clone)]
  pub enum SetParam {
    SetPath(String),
    SetName(String),
    ConnectFiles(Vec<super::file::UniqueWhereParam>),
    DisconnectFiles(Vec<super::file::UniqueWhereParam>),
    SetFiles(Vec<super::file::UniqueWhereParam>),
    SetVisibility(bool),
    SetCreatedAt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
    SetUpdatedAt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
  }
  impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
    fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
      match self {
        SetParam::SetPath(value) => (
          "path".to_string(),
          ::prisma_client_rust::PrismaValue::String(value),
        ),
        SetParam::SetName(value) => (
          "name".to_string(),
          ::prisma_client_rust::PrismaValue::String(value),
        ),
        SetParam::ConnectFiles(where_params) => (
          "files".to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "connect".to_string(),
            ::prisma_client_rust::PrismaValue::List(
              where_params
                .into_iter()
                .map(Into::<super::file::WhereParam>::into)
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                .collect(),
            ),
          )]),
        ),
        SetParam::DisconnectFiles(where_params) => (
          "files".to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "disconnect".to_string(),
            ::prisma_client_rust::PrismaValue::List(
              where_params
                .into_iter()
                .map(Into::<super::file::WhereParam>::into)
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                .collect(),
            ),
          )]),
        ),
        SetParam::SetFiles(where_params) => (
          "files".to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "set".to_string(),
            ::prisma_client_rust::PrismaValue::List(
              where_params
                .into_iter()
                .map(Into::<super::file::WhereParam>::into)
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                .map(|v| ::prisma_client_rust::PrismaValue::Object(vec![v]))
                .collect(),
            ),
          )]),
        ),
        SetParam::SetVisibility(value) => (
          "visibility".to_string(),
          ::prisma_client_rust::PrismaValue::Boolean(value),
        ),
        SetParam::SetCreatedAt(value) => (
          "createdAt".to_string(),
          ::prisma_client_rust::PrismaValue::DateTime(value),
        ),
        SetParam::SetUpdatedAt(value) => (
          "updatedAt".to_string(),
          ::prisma_client_rust::PrismaValue::DateTime(value),
        ),
      }
    }
  }
  #[derive(Clone)]
  pub enum OrderByParam {
    Path(::prisma_client_rust::Direction),
    Name(::prisma_client_rust::Direction),
    Visibility(::prisma_client_rust::Direction),
    CreatedAt(::prisma_client_rust::Direction),
    UpdatedAt(::prisma_client_rust::Direction),
  }
  impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
    fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
      match self {
        Self::Path(direction) => (
          "path".to_string(),
          ::prisma_client_rust::PrismaValue::String(direction.to_string()),
        ),
        Self::Name(direction) => (
          "name".to_string(),
          ::prisma_client_rust::PrismaValue::String(direction.to_string()),
        ),
        Self::Visibility(direction) => (
          "visibility".to_string(),
          ::prisma_client_rust::PrismaValue::String(direction.to_string()),
        ),
        Self::CreatedAt(direction) => (
          "createdAt".to_string(),
          ::prisma_client_rust::PrismaValue::String(direction.to_string()),
        ),
        Self::UpdatedAt(direction) => (
          "updatedAt".to_string(),
          ::prisma_client_rust::PrismaValue::String(direction.to_string()),
        ),
      }
    }
  }
  #[derive(Clone)]
  pub enum WhereParam {
    Not(Vec<WhereParam>),
    Or(Vec<WhereParam>),
    And(Vec<WhereParam>),
    Path(_prisma::read_filters::StringFilter),
    Name(_prisma::read_filters::StringFilter),
    FilesSome(Vec<super::file::WhereParam>),
    FilesEvery(Vec<super::file::WhereParam>),
    FilesNone(Vec<super::file::WhereParam>),
    Visibility(_prisma::read_filters::BoolFilter),
    CreatedAt(_prisma::read_filters::DateTimeFilter),
    UpdatedAt(_prisma::read_filters::DateTimeFilter),
  }
  impl ::prisma_client_rust::WhereInput for WhereParam {
    fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
      let (name, value) = match self {
        Self::Not(value) => (
          "NOT",
          ::prisma_client_rust::SerializedWhereValue::Object(::prisma_client_rust::merge_fields(
            value
              .into_iter()
              .map(::prisma_client_rust::WhereInput::serialize)
              .map(Into::into)
              .collect(),
          )),
        ),
        Self::Or(value) => (
          "OR",
          ::prisma_client_rust::SerializedWhereValue::List(
            value
              .into_iter()
              .map(::prisma_client_rust::WhereInput::serialize)
              .map(Into::into)
              .map(|v| vec![v])
              .map(::prisma_client_rust::PrismaValue::Object)
              .collect(),
          ),
        ),
        Self::And(value) => (
          "AND",
          ::prisma_client_rust::SerializedWhereValue::Object(::prisma_client_rust::merge_fields(
            value
              .into_iter()
              .map(::prisma_client_rust::WhereInput::serialize)
              .map(Into::into)
              .collect(),
          )),
        ),
        Self::Path(value) => ("path", value.into()),
        Self::Name(value) => ("name", value.into()),
        Self::FilesSome(where_params) => (
          "files",
          ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "some".to_string(),
            ::prisma_client_rust::PrismaValue::Object(
              where_params
                .into_iter()
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                .collect(),
            ),
          )]),
        ),
        Self::FilesEvery(where_params) => (
          "files",
          ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "every".to_string(),
            ::prisma_client_rust::PrismaValue::Object(
              where_params
                .into_iter()
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                .collect(),
            ),
          )]),
        ),
        Self::FilesNone(where_params) => (
          "files",
          ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "none".to_string(),
            ::prisma_client_rust::PrismaValue::Object(
              where_params
                .into_iter()
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                .collect(),
            ),
          )]),
        ),
        Self::Visibility(value) => ("visibility", value.into()),
        Self::CreatedAt(value) => ("createdAt", value.into()),
        Self::UpdatedAt(value) => ("updatedAt", value.into()),
      };
      ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
    }
  }
  #[derive(Clone)]
  pub enum UniqueWhereParam {
    PathEquals(String),
  }
  impl From<UniqueWhereParam> for WhereParam {
    fn from(value: UniqueWhereParam) -> Self {
      match value {
        UniqueWhereParam::PathEquals(value) => {
          Self::Path(_prisma::read_filters::StringFilter::Equals(value))
        }
      }
    }
  }
  impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
    fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
      match op {
        ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
        ::prisma_client_rust::Operator::And(value) => Self::And(value),
        ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
      }
    }
  }
  #[derive(Clone)]
  pub struct Types;
  impl ::prisma_client_rust::ModelTypes for Types {
    type Data = Data;
    type Where = WhereParam;
    type Set = SetParam;
    type With = WithParam;
    type OrderBy = OrderByParam;
    type Cursor = UniqueWhereParam;
    const MODEL: &'static str = "Directory";
    fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
      ["path", "name", "visibility", "createdAt", "updatedAt"]
        .into_iter()
        .map(::prisma_client_rust::sel)
        .collect()
    }
  }
  pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
  pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
  pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
  pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
  pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
  pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
  pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
  pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
  pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
  pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
  pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
  pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
  pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
  #[derive(Clone)]
  pub struct Actions<'a> {
    pub client: &'a ::prisma_client_rust::PrismaClientInternals,
  }
  impl<'a> Actions<'a> {
    pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
      FindUnique::new(self.client, _where.into())
    }
    pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
      FindFirst::new(self.client, _where)
    }
    pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
      FindMany::new(self.client, _where)
    }
    pub fn create(
      self,
      path: String,
      name: String,
      visibility: bool,
      mut _params: Vec<SetParam>,
    ) -> Create<'a> {
      _params.push(path::set(path));
      _params.push(name::set(name));
      _params.push(visibility::set(visibility));
      Create::new(self.client, _params)
    }
    pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
      Update::new(self.client, _where.into(), _params, vec![])
    }
    pub fn update_many(self, _where: Vec<WhereParam>, _params: Vec<SetParam>) -> UpdateMany<'a> {
      UpdateMany::new(self.client, _where, _params)
    }
    pub fn upsert(
      self,
      _where: UniqueWhereParam,
      (path, name, visibility, mut _params): (String, String, bool, Vec<SetParam>),
      _update: Vec<SetParam>,
    ) -> Upsert<'a> {
      _params.push(path::set(path));
      _params.push(name::set(name));
      _params.push(visibility::set(visibility));
      Upsert::new(self.client, _where.into(), _params, _update)
    }
    pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
      Delete::new(self.client, _where.into(), vec![])
    }
    pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
      DeleteMany::new(self.client, _where)
    }
    pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
      Count::new(self.client, _where)
    }
  }
}
pub mod file {
  use super::_prisma::*;
  use super::*;
  pub mod id {
    use super::super::*;
    use super::_prisma::*;
    use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
    pub struct Set(pub i32);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetId(value.0)
      }
    }
    pub fn set<T: From<Set>>(value: i32) -> T {
      Set(value).into()
    }
    pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
      OrderByParam::Id(direction)
    }
    pub fn equals<T: From<UniqueWhereParam>>(value: i32) -> T {
      UniqueWhereParam::IdEquals(value).into()
    }
    pub fn in_vec(value: Vec<i32>) -> WhereParam {
      WhereParam::Id(_prisma::read_filters::IntFilter::InVec(value))
    }
    pub fn not_in_vec(value: Vec<i32>) -> WhereParam {
      WhereParam::Id(_prisma::read_filters::IntFilter::NotInVec(value))
    }
    pub fn lt(value: i32) -> WhereParam {
      WhereParam::Id(_prisma::read_filters::IntFilter::Lt(value))
    }
    pub fn lte(value: i32) -> WhereParam {
      WhereParam::Id(_prisma::read_filters::IntFilter::Lte(value))
    }
    pub fn gt(value: i32) -> WhereParam {
      WhereParam::Id(_prisma::read_filters::IntFilter::Gt(value))
    }
    pub fn gte(value: i32) -> WhereParam {
      WhereParam::Id(_prisma::read_filters::IntFilter::Gte(value))
    }
    pub fn not(value: i32) -> WhereParam {
      WhereParam::Id(_prisma::read_filters::IntFilter::Not(value))
    }
    pub fn increment(value: i32) -> SetParam {
      SetParam::IncrementId(value)
    }
    pub fn decrement(value: i32) -> SetParam {
      SetParam::DecrementId(value)
    }
    pub fn multiply(value: i32) -> SetParam {
      SetParam::MultiplyId(value)
    }
    pub fn divide(value: i32) -> SetParam {
      SetParam::DivideId(value)
    }
    pub struct Include;
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::Id(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel("id")
      }
    }
    pub struct Select;
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::Id(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel("id")
      }
    }
  }
  pub mod path {
    use super::super::*;
    use super::_prisma::*;
    use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
    pub struct Set(pub String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetPath(value.0)
      }
    }
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
      OrderByParam::Path(direction)
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::Path(_prisma::read_filters::StringFilter::Equals(value))
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::Path(_prisma::read_filters::StringFilter::InVec(value))
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::Path(_prisma::read_filters::StringFilter::NotInVec(value))
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::Path(_prisma::read_filters::StringFilter::Lt(value))
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::Path(_prisma::read_filters::StringFilter::Lte(value))
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::Path(_prisma::read_filters::StringFilter::Gt(value))
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::Path(_prisma::read_filters::StringFilter::Gte(value))
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::Path(_prisma::read_filters::StringFilter::Contains(value))
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::Path(_prisma::read_filters::StringFilter::StartsWith(value))
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::Path(_prisma::read_filters::StringFilter::EndsWith(value))
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::Path(_prisma::read_filters::StringFilter::Not(value))
    }
    pub struct Include;
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::Path(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel("path")
      }
    }
    pub struct Select;
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::Path(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel("path")
      }
    }
  }
  pub mod name {
    use super::super::*;
    use super::_prisma::*;
    use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
    pub struct Set(pub String);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetName(value.0)
      }
    }
    pub fn set<T: From<Set>>(value: String) -> T {
      Set(value).into()
    }
    pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
      OrderByParam::Name(direction)
    }
    pub fn equals(value: String) -> WhereParam {
      WhereParam::Name(_prisma::read_filters::StringFilter::Equals(value))
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::Name(_prisma::read_filters::StringFilter::InVec(value))
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::Name(_prisma::read_filters::StringFilter::NotInVec(value))
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::Name(_prisma::read_filters::StringFilter::Lt(value))
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::Name(_prisma::read_filters::StringFilter::Lte(value))
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::Name(_prisma::read_filters::StringFilter::Gt(value))
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::Name(_prisma::read_filters::StringFilter::Gte(value))
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::Name(_prisma::read_filters::StringFilter::Contains(value))
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::Name(_prisma::read_filters::StringFilter::StartsWith(value))
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::Name(_prisma::read_filters::StringFilter::EndsWith(value))
    }
    pub fn not(value: String) -> WhereParam {
      WhereParam::Name(_prisma::read_filters::StringFilter::Not(value))
    }
    pub struct Include;
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::Name(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel("name")
      }
    }
    pub struct Select;
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::Name(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel("name")
      }
    }
  }
  pub mod directory {
    use super::super::*;
    use super::_prisma::*;
    use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
    pub struct Fetch(pub directory::UniqueArgs);
    impl Fetch {
      pub fn with(mut self, params: impl Into<directory::WithParam>) -> Self {
        self.0 = self.0.with(params.into());
        self
      }
    }
    impl From<Fetch> for WithParam {
      fn from(fetch: Fetch) -> Self {
        WithParam::Directory(fetch.0)
      }
    }
    pub fn fetch() -> Fetch {
      Fetch(directory::UniqueArgs::new())
    }
    pub struct Connect(directory::UniqueWhereParam);
    impl From<Connect> for SetParam {
      fn from(value: Connect) -> Self {
        Self::ConnectDirectory(value.0)
      }
    }
    pub fn connect<T: From<Connect>>(value: directory::UniqueWhereParam) -> T {
      Connect(value).into()
    }
    pub fn disconnect() -> SetParam {
      SetParam::DisconnectDirectory
    }
    pub fn is_null() -> WhereParam {
      WhereParam::DirectoryIsNull
    }
    pub fn is(value: Vec<directory::WhereParam>) -> WhereParam {
      WhereParam::DirectoryIs(value)
    }
    pub fn is_not(value: Vec<directory::WhereParam>) -> WhereParam {
      WhereParam::DirectoryIsNot(value)
    }
    pub enum Include {
      Select(Vec<directory::SelectParam>),
      Include(Vec<directory::IncludeParam>),
      Fetch,
    }
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::Directory(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        let selections = match self {
          Self::Select(selections) => selections.into_iter().map(|s| s.to_selection()).collect(),
          Self::Include(selections) => {
            let mut nested_selections =
              <directory::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
            nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
            nested_selections
          }
          Self::Fetch => {
            <directory::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
          }
        };
        ::prisma_client_rust::Selection::new("directory", None, [], selections)
      }
      pub fn select(nested_selections: Vec<directory::SelectParam>) -> Self {
        Self::Select(nested_selections)
      }
      pub fn include(nested_selections: Vec<directory::IncludeParam>) -> Self {
        Self::Include(nested_selections)
      }
    }
    pub enum Select {
      Select(Vec<directory::SelectParam>),
      Include(Vec<directory::IncludeParam>),
      Fetch,
    }
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::Directory(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        let selections = match self {
          Self::Select(selections) => selections.into_iter().map(|s| s.to_selection()).collect(),
          Self::Include(selections) => {
            let mut nested_selections = vec![];
            nested_selections.extend(selections.into_iter().map(|s| s.to_selection()));
            nested_selections
          }
          Self::Fetch => {
            <directory::Types as ::prisma_client_rust::ModelTypes>::scalar_selections()
          }
        };
        ::prisma_client_rust::Selection::new("directory", None, [], selections)
      }
      pub fn select(nested_selections: Vec<directory::SelectParam>) -> Self {
        Self::Select(nested_selections)
      }
      pub fn include(nested_selections: Vec<directory::IncludeParam>) -> Self {
        Self::Include(nested_selections)
      }
    }
  }
  pub mod directory_path {
    use super::super::*;
    use super::_prisma::*;
    use super::{OrderByParam, SetParam, UniqueWhereParam, WhereParam, WithParam};
    pub struct Set(pub Option<String>);
    impl From<Set> for SetParam {
      fn from(value: Set) -> Self {
        Self::SetDirectoryPath(value.0)
      }
    }
    pub fn set<T: From<Set>>(value: Option<String>) -> T {
      Set(value).into()
    }
    pub fn order(direction: ::prisma_client_rust::Direction) -> OrderByParam {
      OrderByParam::DirectoryPath(direction)
    }
    pub fn equals(value: Option<String>) -> WhereParam {
      WhereParam::DirectoryPath(_prisma::read_filters::StringNullableFilter::Equals(value))
    }
    pub fn in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::DirectoryPath(_prisma::read_filters::StringNullableFilter::InVec(value))
    }
    pub fn not_in_vec(value: Vec<String>) -> WhereParam {
      WhereParam::DirectoryPath(_prisma::read_filters::StringNullableFilter::NotInVec(value))
    }
    pub fn lt(value: String) -> WhereParam {
      WhereParam::DirectoryPath(_prisma::read_filters::StringNullableFilter::Lt(value))
    }
    pub fn lte(value: String) -> WhereParam {
      WhereParam::DirectoryPath(_prisma::read_filters::StringNullableFilter::Lte(value))
    }
    pub fn gt(value: String) -> WhereParam {
      WhereParam::DirectoryPath(_prisma::read_filters::StringNullableFilter::Gt(value))
    }
    pub fn gte(value: String) -> WhereParam {
      WhereParam::DirectoryPath(_prisma::read_filters::StringNullableFilter::Gte(value))
    }
    pub fn contains(value: String) -> WhereParam {
      WhereParam::DirectoryPath(_prisma::read_filters::StringNullableFilter::Contains(value))
    }
    pub fn starts_with(value: String) -> WhereParam {
      WhereParam::DirectoryPath(_prisma::read_filters::StringNullableFilter::StartsWith(
        value,
      ))
    }
    pub fn ends_with(value: String) -> WhereParam {
      WhereParam::DirectoryPath(_prisma::read_filters::StringNullableFilter::EndsWith(value))
    }
    pub fn not(value: Option<String>) -> WhereParam {
      WhereParam::DirectoryPath(_prisma::read_filters::StringNullableFilter::Not(value))
    }
    pub struct Include;
    impl Into<super::IncludeParam> for Include {
      fn into(self) -> super::IncludeParam {
        super::IncludeParam::DirectoryPath(self)
      }
    }
    impl Include {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel("directoryPath")
      }
    }
    pub struct Select;
    impl Into<super::SelectParam> for Select {
      fn into(self) -> super::SelectParam {
        super::SelectParam::DirectoryPath(self)
      }
    }
    impl Select {
      pub fn to_selection(self) -> ::prisma_client_rust::Selection {
        ::prisma_client_rust::sel("directoryPath")
      }
    }
  }
  pub fn create(
    path: String,
    name: String,
    _params: Vec<SetParam>,
  ) -> (String, String, Vec<SetParam>) {
    (path, name, _params)
  }
  pub fn create_unchecked(
    path: String,
    name: String,
    _params: Vec<SetParam>,
  ) -> (String, String, Vec<SetParam>) {
    (path, name, _params)
  }
  #[macro_export]
  macro_rules ! _select_file { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: file :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = $ crate :: prisma :: file :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([$ crate :: prisma :: file :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: file :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = $ crate :: prisma :: file :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([$ crate :: prisma :: file :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , path , name , directory , directory_path } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : $ crate :: prisma :: file :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: file :: select ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: file :: select ! (@ field_serde_name ; $ field) , ", ") , + ,)) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: file :: select ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: file :: select ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: file :: select ! (@ field_serde_name ; $ field))) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "path" , "name" , "directory" , "directoryPath"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: file :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { i32 } ; (@ field_type ; path) => { String } ; (@ field_type ; name) => { String } ; (@ field_type ; directory : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < directory :: Data > } ; (@ field_type ; directory) => { Option < crate :: prisma :: directory :: Data > } ; (@ field_type ; directory_path) => { Option < String > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "File" , available relations are "id, path, name, directory, directory_path")) } ; (@ field_module ; directory : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: directory :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < $ crate :: prisma :: file :: SelectParam > :: into ($ crate :: prisma :: file :: id :: Select) } ; (@ selection_field_to_selection_param ; path) => { Into :: < $ crate :: prisma :: file :: SelectParam > :: into ($ crate :: prisma :: file :: path :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < $ crate :: prisma :: file :: SelectParam > :: into ($ crate :: prisma :: file :: name :: Select) } ; (@ selection_field_to_selection_param ; directory $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: file :: SelectParam > :: into ($ crate :: prisma :: file :: directory :: Select :: $ selection_mode ($ crate :: prisma :: directory :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; directory $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: file :: SelectParam > :: into ($ crate :: prisma :: file :: directory :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; directory_path) => { Into :: < $ crate :: prisma :: file :: SelectParam > :: into ($ crate :: prisma :: file :: directory_path :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: file :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; path) => { "path" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; directory) => { "directory" } ; (@ field_serde_name ; directory_path) => { "directoryPath" } ; }
  pub use _select_file as select;
  pub enum SelectParam {
    Id(id::Select),
    Path(path::Select),
    Name(name::Select),
    Directory(directory::Select),
    DirectoryPath(directory_path::Select),
  }
  impl SelectParam {
    pub fn to_selection(self) -> ::prisma_client_rust::Selection {
      match self {
        Self::Id(data) => data.to_selection(),
        Self::Path(data) => data.to_selection(),
        Self::Name(data) => data.to_selection(),
        Self::Directory(data) => data.to_selection(),
        Self::DirectoryPath(data) => data.to_selection(),
      }
    }
  }
  #[macro_export]
  macro_rules ! _include_file { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { $ crate :: prisma :: file :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = $ crate :: prisma :: file :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([$ crate :: prisma :: file :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < $ crate :: prisma :: file :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { $ crate :: prisma :: file :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = $ crate :: prisma :: file :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([$ crate :: prisma :: file :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < $ crate :: prisma :: file :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { directory } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : i32 , pub path : String , pub name : String , pub directory_path : Option < String > , $ (pub $ field : $ crate :: prisma :: file :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (path) , stringify ! (name) , stringify ! (directory_path)] . len ()) ? ; $ (state . serialize_field ($ crate :: prisma :: file :: include ! (@ field_serde_name ; $ field) , & self . $ field) ? ;) * state . serialize_field ($ crate :: prisma :: file :: include ! (@ field_serde_name ; id) , & self . id) ? ; state . serialize_field ($ crate :: prisma :: file :: include ! (@ field_serde_name ; path) , & self . path) ? ; state . serialize_field ($ crate :: prisma :: file :: include ! (@ field_serde_name ; name) , & self . name) ? ; state . serialize_field ($ crate :: prisma :: file :: include ! (@ field_serde_name ; directory_path) , & self . directory_path) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , path , name , directory_path } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (concat ! ($ ($ crate :: prisma :: file :: include ! (@ field_serde_name ; $ field) , ", ") , + , $ crate :: prisma :: file :: include ! (@ field_serde_name ; id) , ", " , $ crate :: prisma :: file :: include ! (@ field_serde_name ; path) , ", " , $ crate :: prisma :: file :: include ! (@ field_serde_name ; name) , ", " , $ crate :: prisma :: file :: include ! (@ field_serde_name ; directory_path) , ", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ ($ crate :: prisma :: file :: include ! (@ field_serde_name ; $ field) => Ok (Field :: $ field)) , * , $ crate :: prisma :: file :: include ! (@ field_serde_name ; id) => Ok (Field :: id) , $ crate :: prisma :: file :: include ! (@ field_serde_name ; path) => Ok (Field :: path) , $ crate :: prisma :: file :: include ! (@ field_serde_name ; name) => Ok (Field :: name) , $ crate :: prisma :: file :: include ! (@ field_serde_name ; directory_path) => Ok (Field :: directory_path) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut path = None ; let mut name = None ; let mut directory_path = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: file :: include ! (@ field_serde_name ; id))) ; } id = Some (map . next_value () ?) ; } Field :: path => { if path . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: file :: include ! (@ field_serde_name ; path))) ; } path = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: file :: include ! (@ field_serde_name ; name))) ; } name = Some (map . next_value () ?) ; } Field :: directory_path => { if directory_path . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: file :: include ! (@ field_serde_name ; directory_path))) ; } directory_path = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field ($ crate :: prisma :: file :: include ! (@ field_serde_name ; $ field))) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: file :: include ! (@ field_serde_name ; $ field))) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: file :: include ! (@ field_serde_name ; id))) ? ; let path = path . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: file :: include ! (@ field_serde_name ; path))) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: file :: include ! (@ field_serde_name ; name))) ? ; let directory_path = directory_path . ok_or_else (|| serde :: de :: Error :: missing_field ($ crate :: prisma :: file :: include ! (@ field_serde_name ; directory_path))) ? ; Ok (Data { id , path , name , directory_path , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "path" , "name" , "directory" , "directoryPath"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { $ crate :: prisma :: file :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; directory : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < directory :: Data > } ; (@ field_type ; directory) => { Option < crate :: prisma :: directory :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "File" , available relations are "directory")) } ; (@ field_module ; directory : $ selection_mode : ident { $ ($ selections : tt) + }) => { $ crate :: prisma :: directory :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; directory $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < $ crate :: prisma :: file :: IncludeParam > :: into ($ crate :: prisma :: file :: directory :: Include :: $ selection_mode ($ crate :: prisma :: directory :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; directory $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < $ crate :: prisma :: file :: IncludeParam > :: into ($ crate :: prisma :: file :: directory :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ ($ crate :: prisma :: file :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; path) => { "path" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; directory) => { "directory" } ; (@ field_serde_name ; directory_path) => { "directoryPath" } ; }
  pub use _include_file as include;
  pub enum IncludeParam {
    Id(id::Include),
    Path(path::Include),
    Name(name::Include),
    Directory(directory::Include),
    DirectoryPath(directory_path::Include),
  }
  impl IncludeParam {
    pub fn to_selection(self) -> ::prisma_client_rust::Selection {
      match self {
        Self::Id(data) => data.to_selection(),
        Self::Path(data) => data.to_selection(),
        Self::Name(data) => data.to_selection(),
        Self::Directory(data) => data.to_selection(),
        Self::DirectoryPath(data) => data.to_selection(),
      }
    }
  }
  #[derive(Debug, Clone, :: serde :: Serialize, :: serde :: Deserialize)]
  pub struct Data {
    #[serde(rename = "id")]
    pub id: i32,
    #[serde(rename = "path")]
    pub path: String,
    #[serde(rename = "name")]
    pub name: String,
    #[serde(
      rename = "directory",
      default,
      skip_serializing_if = "Option::is_none",
      with = "prisma_client_rust::serde::double_option"
    )]
    pub directory: Option<Option<Box<super::directory::Data>>>,
    #[serde(rename = "directoryPath")]
    pub directory_path: Option<String>,
  }
  impl Data {
    pub fn directory(
      &self,
    ) -> Result<Option<&super::directory::Data>, ::prisma_client_rust::RelationNotFetchedError>
    {
      self
        .directory
        .as_ref()
        .ok_or(::prisma_client_rust::RelationNotFetchedError::new(
          stringify!(directory),
        ))
        .map(|v| v.as_ref().map(|v| v.as_ref()))
    }
  }
  #[derive(Clone)]
  pub enum WithParam {
    Directory(super::directory::UniqueArgs),
  }
  impl Into<::prisma_client_rust::Selection> for WithParam {
    fn into(self) -> ::prisma_client_rust::Selection {
      match self {
        Self::Directory(args) => {
          let mut selections =
            <super::directory::Types as ::prisma_client_rust::ModelTypes>::scalar_selections();
          selections.extend(
            args
              .with_params
              .into_iter()
              .map(Into::<::prisma_client_rust::Selection>::into),
          );
          ::prisma_client_rust::Selection::new("directory", None, [], selections)
        }
      }
    }
  }
  #[derive(Clone)]
  pub enum SetParam {
    SetId(i32),
    IncrementId(i32),
    DecrementId(i32),
    MultiplyId(i32),
    DivideId(i32),
    SetPath(String),
    SetName(String),
    ConnectDirectory(super::directory::UniqueWhereParam),
    DisconnectDirectory,
    SetDirectoryPath(Option<String>),
  }
  impl Into<(String, ::prisma_client_rust::PrismaValue)> for SetParam {
    fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
      match self {
        SetParam::SetId(value) => (
          "id".to_string(),
          ::prisma_client_rust::PrismaValue::Int(value as i64),
        ),
        SetParam::IncrementId(value) => (
          "id".to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "increment".to_string(),
            ::prisma_client_rust::PrismaValue::Int(value as i64),
          )]),
        ),
        SetParam::DecrementId(value) => (
          "id".to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "decrement".to_string(),
            ::prisma_client_rust::PrismaValue::Int(value as i64),
          )]),
        ),
        SetParam::MultiplyId(value) => (
          "id".to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "multiply".to_string(),
            ::prisma_client_rust::PrismaValue::Int(value as i64),
          )]),
        ),
        SetParam::DivideId(value) => (
          "id".to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "divide".to_string(),
            ::prisma_client_rust::PrismaValue::Int(value as i64),
          )]),
        ),
        SetParam::SetPath(value) => (
          "path".to_string(),
          ::prisma_client_rust::PrismaValue::String(value),
        ),
        SetParam::SetName(value) => (
          "name".to_string(),
          ::prisma_client_rust::PrismaValue::String(value),
        ),
        SetParam::ConnectDirectory(where_param) => (
          "directory".to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "connect".to_string(),
            ::prisma_client_rust::PrismaValue::Object(
              [where_param]
                .into_iter()
                .map(Into::<super::directory::WhereParam>::into)
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                .collect(),
            ),
          )]),
        ),
        SetParam::DisconnectDirectory => (
          "directory".to_string(),
          ::prisma_client_rust::PrismaValue::Object(vec![(
            "disconnect".to_string(),
            ::prisma_client_rust::PrismaValue::Boolean(true),
          )]),
        ),
        SetParam::SetDirectoryPath(value) => (
          "directoryPath".to_string(),
          value
            .map(|value| ::prisma_client_rust::PrismaValue::String(value))
            .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
        ),
      }
    }
  }
  #[derive(Clone)]
  pub enum OrderByParam {
    Id(::prisma_client_rust::Direction),
    Path(::prisma_client_rust::Direction),
    Name(::prisma_client_rust::Direction),
    DirectoryPath(::prisma_client_rust::Direction),
  }
  impl Into<(String, ::prisma_client_rust::PrismaValue)> for OrderByParam {
    fn into(self) -> (String, ::prisma_client_rust::PrismaValue) {
      match self {
        Self::Id(direction) => (
          "id".to_string(),
          ::prisma_client_rust::PrismaValue::String(direction.to_string()),
        ),
        Self::Path(direction) => (
          "path".to_string(),
          ::prisma_client_rust::PrismaValue::String(direction.to_string()),
        ),
        Self::Name(direction) => (
          "name".to_string(),
          ::prisma_client_rust::PrismaValue::String(direction.to_string()),
        ),
        Self::DirectoryPath(direction) => (
          "directoryPath".to_string(),
          ::prisma_client_rust::PrismaValue::String(direction.to_string()),
        ),
      }
    }
  }
  #[derive(Clone)]
  pub enum WhereParam {
    Not(Vec<WhereParam>),
    Or(Vec<WhereParam>),
    And(Vec<WhereParam>),
    Id(_prisma::read_filters::IntFilter),
    Path(_prisma::read_filters::StringFilter),
    Name(_prisma::read_filters::StringFilter),
    DirectoryIsNull,
    DirectoryIs(Vec<super::directory::WhereParam>),
    DirectoryIsNot(Vec<super::directory::WhereParam>),
    DirectoryPath(_prisma::read_filters::StringNullableFilter),
  }
  impl ::prisma_client_rust::WhereInput for WhereParam {
    fn serialize(self) -> ::prisma_client_rust::SerializedWhereInput {
      let (name, value) = match self {
        Self::Not(value) => (
          "NOT",
          ::prisma_client_rust::SerializedWhereValue::Object(::prisma_client_rust::merge_fields(
            value
              .into_iter()
              .map(::prisma_client_rust::WhereInput::serialize)
              .map(Into::into)
              .collect(),
          )),
        ),
        Self::Or(value) => (
          "OR",
          ::prisma_client_rust::SerializedWhereValue::List(
            value
              .into_iter()
              .map(::prisma_client_rust::WhereInput::serialize)
              .map(Into::into)
              .map(|v| vec![v])
              .map(::prisma_client_rust::PrismaValue::Object)
              .collect(),
          ),
        ),
        Self::And(value) => (
          "AND",
          ::prisma_client_rust::SerializedWhereValue::Object(::prisma_client_rust::merge_fields(
            value
              .into_iter()
              .map(::prisma_client_rust::WhereInput::serialize)
              .map(Into::into)
              .collect(),
          )),
        ),
        Self::Id(value) => ("id", value.into()),
        Self::Path(value) => ("path", value.into()),
        Self::Name(value) => ("name", value.into()),
        Self::DirectoryIsNull => (
          "directory",
          ::prisma_client_rust::SerializedWhereValue::Value(
            ::prisma_client_rust::PrismaValue::Null,
          ),
        ),
        Self::DirectoryIs(where_params) => (
          "directory",
          ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "is".to_string(),
            ::prisma_client_rust::PrismaValue::Object(
              where_params
                .into_iter()
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                .collect(),
            ),
          )]),
        ),
        Self::DirectoryIsNot(where_params) => (
          "directory",
          ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "isNot".to_string(),
            ::prisma_client_rust::PrismaValue::Object(
              where_params
                .into_iter()
                .map(::prisma_client_rust::WhereInput::serialize)
                .map(::prisma_client_rust::SerializedWhereInput::transform_equals)
                .collect(),
            ),
          )]),
        ),
        Self::DirectoryPath(value) => ("directoryPath", value.into()),
      };
      ::prisma_client_rust::SerializedWhereInput::new(name, value.into())
    }
  }
  #[derive(Clone)]
  pub enum UniqueWhereParam {
    IdEquals(i32),
  }
  impl From<UniqueWhereParam> for WhereParam {
    fn from(value: UniqueWhereParam) -> Self {
      match value {
        UniqueWhereParam::IdEquals(value) => {
          Self::Id(_prisma::read_filters::IntFilter::Equals(value))
        }
      }
    }
  }
  impl From<::prisma_client_rust::Operator<Self>> for WhereParam {
    fn from(op: ::prisma_client_rust::Operator<Self>) -> Self {
      match op {
        ::prisma_client_rust::Operator::Not(value) => Self::Not(value),
        ::prisma_client_rust::Operator::And(value) => Self::And(value),
        ::prisma_client_rust::Operator::Or(value) => Self::Or(value),
      }
    }
  }
  #[derive(Clone)]
  pub struct Types;
  impl ::prisma_client_rust::ModelTypes for Types {
    type Data = Data;
    type Where = WhereParam;
    type Set = SetParam;
    type With = WithParam;
    type OrderBy = OrderByParam;
    type Cursor = UniqueWhereParam;
    const MODEL: &'static str = "File";
    fn scalar_selections() -> Vec<::prisma_client_rust::Selection> {
      ["id", "path", "name", "directoryPath"]
        .into_iter()
        .map(::prisma_client_rust::sel)
        .collect()
    }
  }
  pub type UniqueArgs = ::prisma_client_rust::UniqueArgs<Types>;
  pub type ManyArgs = ::prisma_client_rust::ManyArgs<Types>;
  pub type Count<'a> = ::prisma_client_rust::Count<'a, Types>;
  pub type Create<'a> = ::prisma_client_rust::Create<'a, Types>;
  pub type CreateMany<'a> = ::prisma_client_rust::CreateMany<'a, Types>;
  pub type FindUnique<'a> = ::prisma_client_rust::FindUnique<'a, Types>;
  pub type FindMany<'a> = ::prisma_client_rust::FindMany<'a, Types>;
  pub type FindFirst<'a> = ::prisma_client_rust::FindFirst<'a, Types>;
  pub type Update<'a> = ::prisma_client_rust::Update<'a, Types>;
  pub type UpdateMany<'a> = ::prisma_client_rust::UpdateMany<'a, Types>;
  pub type Upsert<'a> = ::prisma_client_rust::Upsert<'a, Types>;
  pub type Delete<'a> = ::prisma_client_rust::Delete<'a, Types>;
  pub type DeleteMany<'a> = ::prisma_client_rust::DeleteMany<'a, Types>;
  #[derive(Clone)]
  pub struct Actions<'a> {
    pub client: &'a ::prisma_client_rust::PrismaClientInternals,
  }
  impl<'a> Actions<'a> {
    pub fn find_unique(self, _where: UniqueWhereParam) -> FindUnique<'a> {
      FindUnique::new(self.client, _where.into())
    }
    pub fn find_first(self, _where: Vec<WhereParam>) -> FindFirst<'a> {
      FindFirst::new(self.client, _where)
    }
    pub fn find_many(self, _where: Vec<WhereParam>) -> FindMany<'a> {
      FindMany::new(self.client, _where)
    }
    pub fn create(self, path: String, name: String, mut _params: Vec<SetParam>) -> Create<'a> {
      _params.push(path::set(path));
      _params.push(name::set(name));
      Create::new(self.client, _params)
    }
    pub fn update(self, _where: UniqueWhereParam, _params: Vec<SetParam>) -> Update<'a> {
      Update::new(self.client, _where.into(), _params, vec![])
    }
    pub fn update_many(self, _where: Vec<WhereParam>, _params: Vec<SetParam>) -> UpdateMany<'a> {
      UpdateMany::new(self.client, _where, _params)
    }
    pub fn upsert(
      self,
      _where: UniqueWhereParam,
      (path, name, mut _params): (String, String, Vec<SetParam>),
      _update: Vec<SetParam>,
    ) -> Upsert<'a> {
      _params.push(path::set(path));
      _params.push(name::set(name));
      Upsert::new(self.client, _where.into(), _params, _update)
    }
    pub fn delete(self, _where: UniqueWhereParam) -> Delete<'a> {
      Delete::new(self.client, _where.into(), vec![])
    }
    pub fn delete_many(self, _where: Vec<WhereParam>) -> DeleteMany<'a> {
      DeleteMany::new(self.client, _where)
    }
    pub fn count(self, _where: Vec<WhereParam>) -> Count<'a> {
      Count::new(self.client, _where)
    }
  }
}
pub mod _prisma {
  pub struct PrismaClientBuilder {
    url: Option<String>,
    action_notifier: ::prisma_client_rust::ActionNotifier,
  }
  impl PrismaClientBuilder {
    fn new() -> Self {
      Self {
        url: None,
        action_notifier: ::prisma_client_rust::ActionNotifier::new(),
      }
    }
    pub fn with_url(mut self, url: String) -> Self {
      self.url = Some(url);
      self
    }
    pub async fn build(self) -> Result<PrismaClient, ::prisma_client_rust::NewClientError> {
      let internals = ::prisma_client_rust::PrismaClientInternals::new(
        self.url,
        self.action_notifier,
        super::DATAMODEL_STR,
      )
      .await?;
      Ok(PrismaClient(internals))
    }
  }
  pub struct PrismaClient(::prisma_client_rust::PrismaClientInternals);
  impl ::std::fmt::Debug for PrismaClient {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
      f.debug_struct("PrismaClient").finish()
    }
  }
  impl PrismaClient {
    pub fn _builder() -> PrismaClientBuilder {
      PrismaClientBuilder::new()
    }
    pub fn _query_raw<T: ::prisma_client_rust::Data>(
      &self,
      query: ::prisma_client_rust::Raw,
    ) -> ::prisma_client_rust::QueryRaw<T> {
      ::prisma_client_rust::QueryRaw::new(&self.0, query, super::DATABASE_STR)
    }
    pub fn _execute_raw(
      &self,
      query: ::prisma_client_rust::Raw,
    ) -> ::prisma_client_rust::ExecuteRaw {
      ::prisma_client_rust::ExecuteRaw::new(&self.0, query, super::DATABASE_STR)
    }
    pub async fn _batch<'batch, T: ::prisma_client_rust::BatchContainer<'batch, Marker>, Marker>(
      &self,
      queries: T,
    ) -> ::prisma_client_rust::Result<
      <T as ::prisma_client_rust::BatchContainer<'batch, Marker>>::ReturnType,
    > {
      ::prisma_client_rust::batch(queries, &self.0).await
    }
    pub fn _transaction(&self) -> ::prisma_client_rust::TransactionBuilder<Self> {
      ::prisma_client_rust::TransactionBuilder::_new(self, &self.0)
    }
    pub async fn _migrate_deploy(
      &self,
    ) -> Result<(), ::prisma_client_rust::migrations::MigrateDeployError> {
      let res = ::prisma_client_rust::migrations::migrate_deploy(
        super::DATAMODEL_STR,
        super::MIGRATIONS_DIR,
        &self.0.url(),
      )
      .await;
      ::prisma_client_rust::tokio::time::sleep(core::time::Duration::from_millis(1)).await;
      res
    }
    pub async fn _migrate_resolve(
      &self,
      migration: &str,
    ) -> Result<(), ::prisma_client_rust::migrations::MigrateResolveError> {
      ::prisma_client_rust::migrations::migrate_resolve(
        migration,
        super::DATAMODEL_STR,
        super::MIGRATIONS_DIR,
        &self.0.url(),
      )
      .await
    }
    pub fn _db_push(&self) -> ::prisma_client_rust::migrations::DbPush {
      ::prisma_client_rust::migrations::db_push(super::DATAMODEL_STR, &self.0.url())
    }
    pub fn directory(&self) -> super::directory::Actions {
      super::directory::Actions { client: &self.0 }
    }
    pub fn file(&self) -> super::file::Actions {
      super::file::Actions { client: &self.0 }
    }
  }
  impl ::prisma_client_rust::PrismaClient for PrismaClient {
    fn internals(&self) -> &::prisma_client_rust::PrismaClientInternals {
      &self.0
    }
    fn internals_mut(&mut self) -> &mut ::prisma_client_rust::PrismaClientInternals {
      &mut self.0
    }
    fn with_tx_id(&self, tx_id: Option<::prisma_client_rust::query_core::TxId>) -> Self {
      Self(self.0.with_tx_id(tx_id))
    }
  }
  #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
  pub enum DirectoryScalarFieldEnum {
    #[serde(rename = "path")]
    Path,
    #[serde(rename = "name")]
    Name,
    #[serde(rename = "visibility")]
    Visibility,
    #[serde(rename = "createdAt")]
    CreatedAt,
    #[serde(rename = "updatedAt")]
    UpdatedAt,
  }
  impl ToString for DirectoryScalarFieldEnum {
    fn to_string(&self) -> String {
      match self {
        Self::Path => "path".to_string(),
        Self::Name => "name".to_string(),
        Self::Visibility => "visibility".to_string(),
        Self::CreatedAt => "createdAt".to_string(),
        Self::UpdatedAt => "updatedAt".to_string(),
      }
    }
  }
  #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
  pub enum FileScalarFieldEnum {
    #[serde(rename = "id")]
    Id,
    #[serde(rename = "path")]
    Path,
    #[serde(rename = "name")]
    Name,
    #[serde(rename = "directoryPath")]
    DirectoryPath,
  }
  impl ToString for FileScalarFieldEnum {
    fn to_string(&self) -> String {
      match self {
        Self::Id => "id".to_string(),
        Self::Path => "path".to_string(),
        Self::Name => "name".to_string(),
        Self::DirectoryPath => "directoryPath".to_string(),
      }
    }
  }
  #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
  pub enum SortOrder {
    #[serde(rename = "asc")]
    Asc,
    #[serde(rename = "desc")]
    Desc,
  }
  impl ToString for SortOrder {
    fn to_string(&self) -> String {
      match self {
        Self::Asc => "asc".to_string(),
        Self::Desc => "desc".to_string(),
      }
    }
  }
  #[derive(Debug, Clone, Copy, :: serde :: Serialize, :: serde :: Deserialize, PartialEq, Eq)]
  pub enum TransactionIsolationLevel {
    #[serde(rename = "Serializable")]
    Serializable,
  }
  impl ToString for TransactionIsolationLevel {
    fn to_string(&self) -> String {
      match self {
        Self::Serializable => "Serializable".to_string(),
      }
    }
  }
  impl ::prisma_client_rust::TransactionIsolationLevel for TransactionIsolationLevel {}
  pub mod read_filters {
    #[derive(Clone)]
    pub enum StringFilter {
      Equals(String),
      InVec(Vec<String>),
      NotInVec(Vec<String>),
      Lt(String),
      Lte(String),
      Gt(String),
      Gte(String),
      Contains(String),
      StartsWith(String),
      EndsWith(String),
      Not(String),
    }
    impl Into<::prisma_client_rust::SerializedWhereValue> for StringFilter {
      fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
        match self {
          Self::Equals(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "equals".to_string(),
            ::prisma_client_rust::PrismaValue::String(value),
          )]),
          Self::InVec(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "in".to_string(),
            ::prisma_client_rust::PrismaValue::List(
              value
                .into_iter()
                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                .collect(),
            ),
          )]),
          Self::NotInVec(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "notIn".to_string(),
            ::prisma_client_rust::PrismaValue::List(
              value
                .into_iter()
                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                .collect(),
            ),
          )]),
          Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "lt".to_string(),
            ::prisma_client_rust::PrismaValue::String(value),
          )]),
          Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "lte".to_string(),
            ::prisma_client_rust::PrismaValue::String(value),
          )]),
          Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "gt".to_string(),
            ::prisma_client_rust::PrismaValue::String(value),
          )]),
          Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "gte".to_string(),
            ::prisma_client_rust::PrismaValue::String(value),
          )]),
          Self::Contains(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "contains".to_string(),
            ::prisma_client_rust::PrismaValue::String(value),
          )]),
          Self::StartsWith(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "startsWith".to_string(),
            ::prisma_client_rust::PrismaValue::String(value),
          )]),
          Self::EndsWith(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "endsWith".to_string(),
            ::prisma_client_rust::PrismaValue::String(value),
          )]),
          Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "not".to_string(),
            ::prisma_client_rust::PrismaValue::String(value),
          )]),
        }
      }
    }
    #[derive(Clone)]
    pub enum StringNullableFilter {
      Equals(Option<String>),
      InVec(Vec<String>),
      NotInVec(Vec<String>),
      Lt(String),
      Lte(String),
      Gt(String),
      Gte(String),
      Contains(String),
      StartsWith(String),
      EndsWith(String),
      Not(Option<String>),
    }
    impl Into<::prisma_client_rust::SerializedWhereValue> for StringNullableFilter {
      fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
        match self {
          Self::Equals(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "equals".to_string(),
            value
              .map(|value| ::prisma_client_rust::PrismaValue::String(value))
              .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
          )]),
          Self::InVec(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "in".to_string(),
            ::prisma_client_rust::PrismaValue::List(
              value
                .into_iter()
                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                .collect(),
            ),
          )]),
          Self::NotInVec(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "notIn".to_string(),
            ::prisma_client_rust::PrismaValue::List(
              value
                .into_iter()
                .map(|v| ::prisma_client_rust::PrismaValue::String(v))
                .collect(),
            ),
          )]),
          Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "lt".to_string(),
            ::prisma_client_rust::PrismaValue::String(value),
          )]),
          Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "lte".to_string(),
            ::prisma_client_rust::PrismaValue::String(value),
          )]),
          Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "gt".to_string(),
            ::prisma_client_rust::PrismaValue::String(value),
          )]),
          Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "gte".to_string(),
            ::prisma_client_rust::PrismaValue::String(value),
          )]),
          Self::Contains(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "contains".to_string(),
            ::prisma_client_rust::PrismaValue::String(value),
          )]),
          Self::StartsWith(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "startsWith".to_string(),
            ::prisma_client_rust::PrismaValue::String(value),
          )]),
          Self::EndsWith(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "endsWith".to_string(),
            ::prisma_client_rust::PrismaValue::String(value),
          )]),
          Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "not".to_string(),
            value
              .map(|value| ::prisma_client_rust::PrismaValue::String(value))
              .unwrap_or_else(|| ::prisma_client_rust::PrismaValue::Null),
          )]),
        }
      }
    }
    #[derive(Clone)]
    pub enum BoolFilter {
      Equals(bool),
      Not(bool),
    }
    impl Into<::prisma_client_rust::SerializedWhereValue> for BoolFilter {
      fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
        match self {
          Self::Equals(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "equals".to_string(),
            ::prisma_client_rust::PrismaValue::Boolean(value),
          )]),
          Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "not".to_string(),
            ::prisma_client_rust::PrismaValue::Boolean(value),
          )]),
        }
      }
    }
    #[derive(Clone)]
    pub enum DateTimeFilter {
      Equals(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
      InVec(Vec<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>),
      NotInVec(
        Vec<::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>>,
      ),
      Lt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
      Lte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
      Gt(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
      Gte(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
      Not(::prisma_client_rust::chrono::DateTime<::prisma_client_rust::chrono::FixedOffset>),
    }
    impl Into<::prisma_client_rust::SerializedWhereValue> for DateTimeFilter {
      fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
        match self {
          Self::Equals(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "equals".to_string(),
            ::prisma_client_rust::PrismaValue::DateTime(value),
          )]),
          Self::InVec(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "in".to_string(),
            ::prisma_client_rust::PrismaValue::List(
              value
                .into_iter()
                .map(|v| ::prisma_client_rust::PrismaValue::DateTime(v))
                .collect(),
            ),
          )]),
          Self::NotInVec(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "notIn".to_string(),
            ::prisma_client_rust::PrismaValue::List(
              value
                .into_iter()
                .map(|v| ::prisma_client_rust::PrismaValue::DateTime(v))
                .collect(),
            ),
          )]),
          Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "lt".to_string(),
            ::prisma_client_rust::PrismaValue::DateTime(value),
          )]),
          Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "lte".to_string(),
            ::prisma_client_rust::PrismaValue::DateTime(value),
          )]),
          Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "gt".to_string(),
            ::prisma_client_rust::PrismaValue::DateTime(value),
          )]),
          Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "gte".to_string(),
            ::prisma_client_rust::PrismaValue::DateTime(value),
          )]),
          Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "not".to_string(),
            ::prisma_client_rust::PrismaValue::DateTime(value),
          )]),
        }
      }
    }
    #[derive(Clone)]
    pub enum IntFilter {
      Equals(i32),
      InVec(Vec<i32>),
      NotInVec(Vec<i32>),
      Lt(i32),
      Lte(i32),
      Gt(i32),
      Gte(i32),
      Not(i32),
    }
    impl Into<::prisma_client_rust::SerializedWhereValue> for IntFilter {
      fn into(self) -> ::prisma_client_rust::SerializedWhereValue {
        match self {
          Self::Equals(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "equals".to_string(),
            ::prisma_client_rust::PrismaValue::Int(value as i64),
          )]),
          Self::InVec(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "in".to_string(),
            ::prisma_client_rust::PrismaValue::List(
              value
                .into_iter()
                .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                .collect(),
            ),
          )]),
          Self::NotInVec(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "notIn".to_string(),
            ::prisma_client_rust::PrismaValue::List(
              value
                .into_iter()
                .map(|v| ::prisma_client_rust::PrismaValue::Int(v as i64))
                .collect(),
            ),
          )]),
          Self::Lt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "lt".to_string(),
            ::prisma_client_rust::PrismaValue::Int(value as i64),
          )]),
          Self::Lte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "lte".to_string(),
            ::prisma_client_rust::PrismaValue::Int(value as i64),
          )]),
          Self::Gt(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "gt".to_string(),
            ::prisma_client_rust::PrismaValue::Int(value as i64),
          )]),
          Self::Gte(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "gte".to_string(),
            ::prisma_client_rust::PrismaValue::Int(value as i64),
          )]),
          Self::Not(value) => ::prisma_client_rust::SerializedWhereValue::Object(vec![(
            "not".to_string(),
            ::prisma_client_rust::PrismaValue::Int(value as i64),
          )]),
        }
      }
    }
  }
}
pub use _prisma::*;
